# 谷粒商城项目

# 谷粒商城-基础篇开发笔记

## 项目说明

> 该开发笔记主要记录项目的后端开发部分的内容，前端部分不是重点，可能不会深入。

## 商品服务API开发

### 三级分类-递归查询树形结构分类数据

#### 数据库设计/分析

![image-20220806191040210](https://images.waer.ltd/img/image-20220806191040210.png)

该模块属于微服务中的product(商品服务)模块，对应数据库为`gulimall-pms`。

上图是该库中的商品分类数据表的设计实现，由此可知，分类数据中有分类ID、分类的父ID、层级和排序等关键字段，这也是本节主要用到的几个字段。

> 下面是表中的分类数据部分情况，可知，在分类数据中，除了首级分类的父ID为0，其他子分类的父分类ID都是上一个分类的分类ID。

![image-20220806191434773](https://images.waer.ltd/img/image-20220806191434773.png)

为了更好的理解这种关系，可以参考下面的截图：

![image-20220806191738026](https://images.waer.ltd/img/image-20220806191738026.png)

我们的需求是，将所有的分类数据查询出来，并且将按照其中的分类规则用树形结构的方式进行返回展示，前端渲染后如下(截图自京东首页分类)：

![image-20220806192223936](https://images.waer.ltd/img/image-20220806192223936.png)

> 其中手机属于一级分类，其中的运营商和数码分别属于二级分类和三级分类。

基于此，可以总结出，他们的关系其实类似于递归，所以可以通过递归的方式将数据以树形结构的形式查询出来。

具体的，先将全部的分类数据查到，再通过递归的方法查询分类数据的子分类，再以该子分类作为父分类查询他的下一级分类，以此类推，就可以查询到所有数据的分类及其子分类数据。

****

#### 代码实现/讲解

> 基于上述分析，我们分步进行代码实现。

- 查询全部分类数据

> 首先修改`CategoryController`中的【list】方法：

```java
@RequestMapping("/list/tree")
public R list(){
    List<CategoryEntity> entities = categoryService.listWithTree();
    return R.ok().put("data", entities);
}
```

其中的【`listWithTree`】方法的实现如下：

> 1.方法声明

```java
  /**
     * 获取菜单的树形结构
     * @return 返回分类数据
     */
    @Override
    public List<CategoryEntity> listWithTree() {
    	//方法体
    }
```

> 2.查询全部的分类数据。

```java
//1.查出所有的分类数据
List<CategoryEntity>entities= baseMapper.selectList(null);
```

> 构造树形数据结构

```java
List<CategoryEntity>level1Menus = entities
    .stream()
    .filter(categoryEntity -> categoryEntity.getParentCid() == 0)
    .map((menu)-> {
        menu.setChildren(getChildren(menu,entities));
        return menu;
    })
    .sorted((menu1,menu2)->{
        return  (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() ==  null ? 0 :
                                                                   menu2.getSort());
    })
    .collect(Collectors.toList());
return level1Menus;
```

这里主要涉及到了Java中的`Stream`API和`Lambda`表达式语法。

通过filter()方法过滤得到父分类，将分类结果存在map中进行再一次封装，通过传入一个当前分类去查找他的子分类，最后将分类的数据进行排序之后打成集合返回。

其中用来获取当前分类的子分类的方法【`getChildren()`】实现如下：

```java
/**
     * 递归获取当前菜单的所有子菜单
     * @param root 当前菜单
     * @param all 所有菜单
     * @return 当前菜单的子菜单
     */
private List<CategoryEntity> getChildren(CategoryEntity root,List<CategoryEntity> all) {
    List<CategoryEntity> children = all
        .stream()
        .filter(categoryEntity ->{
            /**子菜单的过滤条件*/
            return  categoryEntity.getParentCid() ==  root.getCatId();
        })
        .map((categoryEntity)->{
            /**递归处理：继续查找当前才当categoryEntity的子菜单*/
            categoryEntity.setChildren(getChildrens(categoryEntity,all));
            return categoryEntity;
        })
        .sorted((menu1,menu2)->{
            return (menu1.getSort() == null ? 0 : menu1.getSort()) - (menu2.getSort() == null ? 0 : menu2.getSort());
        })
        .collect(Collectors.toList());

    return children;
}
```

其实这里没什么特别的地方，大致的实现思路和前面的方法类似，只不过他再查找当前传入分类的子分类时也把查找到的子分类作为当前分类参数继续用同样的方法查找他的子分类，以此递归的找下去，最终方法会返回当前分类数据的所有的子分类。

注意，为了能实现这种树形的联机查询，我们需要再对应的实体中再定义一个名为`children`的属性，它并不在数据库中，而是我们自己定义而来，用来存储子分类的实体数据。内容如下：

```java
/**
	 * 使用注解标注该实体不是来自数据库
	 */
@TableField(exist=false)
private List<CategoryEntity> children;
```

> 注解【`@TableField(exist=false)`】表示该属性实体不是来自数据库。

****

#### API测试

> 使用PostMan,由于数据量偏大，这里展示部分数据。

![image-20220806204005872](https://images.waer.ltd/img/image-20220806204005872.png)

****

#### 前后端联调

> 准备好后端API之后，需要和前端进行联合调试，保证数据能够被正常的请求并且渲染到前端页面。

- 调整前端

> 前端请求测试，在/views/modules/product/category.vue中

```js
  getMenus ()
    // eslint-disable-next-line no-lone-blocks,brace-style
      {
      this.$http({
        url: this.$http.adornUrl('product/category/list/tree'),
        method: 'get'
      }).then(data => {
        console.log('获取到数据', data)
      })
    }
```

修改请求base路径。

```js
  // api接口请求地址
  window.SITE_CONFIG['baseUrl'] = 'http://localhost:88/api';
```

> 以上内容在/static/config/index.js中可找到。

我们将所有的前端请求都以统一的前缀路径`/api`开始，由于后端使用了Gateway网关服务(88端口)，所以请求地址不能直接请求product微服务的端口，而是需要通过网关配置，将请求转发给对应的服务进行处理，所以在后端我们还需要配置一下product服务的nacos和Gateway网关信息。

- 配置nacos服务

> 在renren-fast的application.yml中配置nacos相关信息。

```yaml
  application:
    name: renren-fast
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
```

配置内容简单，就是将该服务注册到nacos中心进行管理。

同时为了该服务能够正常使用nacos所需要的依赖，我们需要在其pom.xml中引入之前准备好的共有依赖

`gulimall-common`.

```xml
<dependency>
    <groupId>com.atguigu.gulimall</groupId>
    <artifactId>gulimall-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

启动类上添加`@EnableDiscoveryClient`注解。

- 配置网关

在网关服务的`application.yml`中添加下面的内容：

```yaml
- id: admin_router
uri: lb://renren-fast # 负载均衡到renren-fast
predicates: # 断言路径
- Path=/api/** 
```

> 只要带有`- Path=/api/** `路径前缀的请求我们都认为是后端发送的请求，统一均衡到renren-fast后台。

至此，后端对renren-fast后台管理服务的nacos相关配置基本上结束，我们重启服务。

项目启动之后发现页面不能正常加载登录的验证码信息，浏览器请求情况如下：

![image-20220807084932709](https://images.waer.ltd/img/image-20220807084932709.png)



报错的原因其实很明显，浏览器对验证码的请求地址中，由于带有/api前缀，它会以为这个就是验证码的请求地址，其实，验证码的请求地址是没有这个前缀路径的。

```js
http://localhost:88/api/captcha.jpg  //异常请求地址
http://localhost:8080/renren-fast/captcha.jpg //正常请求地址
```

> 所以问题在于，我们需要将前端发来的请求地址作一个修改，具体的，将/api/替换为/renren-fast/。这就需要用到cateway网关中过滤方法。

在原有配置之后新增如下配置：

```yaml
filters:
- RewritePath=/api/(?<segment>.*),/renren-fast/$\{segment}
```

配置对请求的路径进行了重写转发，该方法会将/api开头的请求路径替换为/renren-fast。

重启服务之后发现验证码可以正常加载了，但出现了跨域异常。

![image-20220807090258369](https://images.waer.ltd/img/image-20220807090258369.png)

- 解决跨域

> 由异常可知，这里触发了不同端口下的跨域。

解决跨域的方法很多，我们这里使用允许跨域的方式，其实在非简单请求中，客户端会先发送一个`OPTION`请求，称为预检请求，作用就是向服务端询问是否允许我跨域访问？在工具服务端的响应来决定是否发起后续的跨域请求，那么基于这个思路，我们只要在服务端配置允许跨域，那不就解决问题了？再者，我们是通过网关统一路由所有的请求，所以这里的跨域解决应该在网关中进行统一配置。

**添加响应头：**

> • Access-Control-Allow-Origin：支持哪些来源的请求跨域

> • Access-Control-Allow-Methods：支持哪些方法跨域 

> • Access-Control-Allow-Credentials：跨域请求默认不包含cookie，设置为true可以包含cookie 

> • Access-Control-Expose-Headers：跨域请求暴露的字段

> • CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。

> • Access-Control-Max-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。

跨域解决如下：

```java
@Configuration
public class GulimallCorsConfiguration {
    /**
     * 统一解决跨域问题
     * @return CorsWebFilter
     */
    @Bean
    public CorsWebFilter corsWebFilter(){
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        //1、配置跨域
        corsConfiguration.addAllowedHeader("*");
        corsConfiguration.addAllowedMethod("*");
        corsConfiguration.addAllowedOrigin("*");
        corsConfiguration.setAllowCredentials(true);
        source.registerCorsConfiguration("/**",corsConfiguration);
        return new CorsWebFilter(source);
    }
}
```

由于renren-fast本身也写了跨域解决方法，所以未了解决冲突，我们统一使用网关中配置的跨域解决方案，以此需要注释掉renen-fast中的跨域解决部分的代码：

![image-20220807092315186](https://images.waer.ltd/img/image-20220807092315186.png)

至此，就可以正常登录后台管理了。更多关于跨域的内容可以参考:[跨源资源共享（CORS）](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)

****



解决跨域问题之后，我们尝试请求后端的product中的分类数据时却发现了404异常：

> 注意看请求路径，我的请求中api后面其实少了一个’/‘,这是我前端baseURL没写全的原因，这不是404的主要原因，请忽略，自己注意就行了。

![image-20220807094550310](https://images.waer.ltd/img/image-20220807094550310.png)

![image-20220807094540801](https://images.waer.ltd/img/image-20220807094540801.png)

问题其实比较容易发现，仔细看请求的地址，尽管我们请求数据的服务应该时product模块，当网关统一将我们的请求发给了`renren-fast`管理后台的服务，对于该服务来说，压根不存在这些分类数据，所以反手就给你返回一个404大嘴巴子。

- 解决404

上面已经简单分析了404的原因，就是网关原生请求和服务地址不符。

> 经过网关的请求路径

```js
http://localhost:88/api/product/category/list/tree 
```

> 最终正确的请求路径

```js
http://localhost:10000/product/category/list/tree
```

所以很明显我们需要进行请求路径的重写，将请求中的`/api`去掉即可。

在product服务模块中添加nacos相关信息:bootstrap.properties

```properties
spring.application.name=gulimall-product
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=a2664336-d2ae-4e94-9ffc-c99d460721ca
```

同时需要在application.yml中添加；

```yaml
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
```

在网关服务中新增对product服务的支持以及路径重写。

```yaml
- id: product_router
uri: lb://gulimall-product
predicates:
- Path=/api/product/**
filters:
- RewritePath=/api/(?<segment>.*),/$\{segment}    
```

记得为每一个模块服务添加一个独立的命名空间，

![image-20220807100606051](https://images.waer.ltd/img/image-20220807100606051.png)

主程序添加注解,开启服务发现功能。

```java
@EnableDiscoveryClient
```

这里其实还有一个问题，如下图，我们在设置多个网关路由的时候，其实下面两个的断言路径都含有相同的部分，所以对于第一个`/api/**`来说，他的优先级是高于后面一个的，所以请求一旦进入网关，就会被优先匹配到`renren-fast`服务中去了，那么后面的分类数据的请求其实并没有打到应该去的`product`服务模块，所以是无法正常请求数据的。

![image-20220807101418708](https://images.waer.ltd/img/image-20220807101418708.png)

解决办法就是换一下他们的顺序，让更精确的路由匹配放到最前面进行优先匹配；

![image-20220807101847466](https://images.waer.ltd/img/image-20220807101847466.png)

重启服务之后就能获取到数据了：

![image-20220807102244427](https://images.waer.ltd/img/image-20220807102244427.png)



- 解析数据

可以看到，我们请求到的数据其实是一个对象类型，里面除了我们本身需要的分类数据之外还包含了很多其他内容，由于我们并不需要其他冗余的内容，所以可以使用对象结构。在前端请求结果中只获取所需要的data中的data数据。

![image-20220807102820268](https://images.waer.ltd/img/image-20220807102820268.png)

![image-20220807102913900](https://images.waer.ltd/img/image-20220807102913900.png)

调整前端：category.vue全部内容如下

```vue
<template>
  <div>
    <el-tree :data="menus" :props="defaultProps" @node-click="handleNodeClick"></el-tree>
  </div>
</template>

<script>
// 这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json 文件，图片文件等等）
// 例如：import  《组件名称》  from '《组件路径》 ';

export default {
  data () {
    return {
      menus: [],
      defaultProps: {
        children: 'children',
        label: 'name'
      }
    }
  },
  methods: {
    handleNodeClick (data) {
      console.log(data)
    },
      // eslint-disable-next-line no-undef
    getMenus ()
    // eslint-disable-next-line no-lone-blocks,brace-style
      {
      this.$http({
        url: this.$http.adornUrl('product/category/list/tree'),
        method: 'get'
      }).then(({data}) => {
        console.log('获取到数据', data.data)
        this.menus = data.data;
      })
    }
  },

  // import 引入的组件需要注入到对象中才能使用
  components: {},
  props: {},
  // 计算属性 类似于 data 概念
  computed: {},
  // 监控 data 中的数据变化
  watch: {},
  // 过滤器
  filters: {},
  // 生命周期 - 创建之前
  beforeCreate () {
  },
  // 生命周期 - 创建完成（可以访问当前this 实例）
  created () {
    this.getMenus()
  },
  // 生命周期 - 挂载之前
  beforeMount () {
  },
  // 生命周期 - 挂载完成（可以访问 DOM 元素）
  mounted () {
  },
  // 生命周期 - 更新之前
  beforeUpdate () {
  },
  // 生命周期 - 更新之后
  updated () {
  },
  // 生命周期 - 销毁之前
  beforeDestroy () {
  },
  // 生命周期 - 销毁完成
  destroyed () {
  },
  // 如果页面有 keep-alive 缓存功能,这个函数会触发
  // 进入的时候触发
  activated () {
  },
  // 离开的时候触发
  deactivated () {
  }
}
</script>

<style scoped>
</style>

```

至此就结束了分类数据的前后端联调，完成了商品分类数据的请求渲染，效果如下：

![image-20220807103751431](https://images.waer.ltd/img/image-20220807103751431.png)

****

### 三级分类-删除单个分类菜单

#### 需求分析

删除又分为物理删除和逻辑删除：

- 物理删除

> 直接删除数据库中的数据，删除执行之后数据将会永久消失，不能恢复。可以直接使用delete语句实现。

- 逻辑删除

> 就是对需要删除的数据只做一个隐藏/展示的效果，一般情况下，我们将数据进行隐藏之后代表该数据已被删除，而实际上它还是存在于数据库中的。一般使用一个标志位作为数据是否删除的标记，我们只需要维护该字段状态即可，使用update实现。

所以这里实现的分类菜单的删除采用逻辑删除的方式。

- 数据库

![image-20220807163656818](https://images.waer.ltd/img/image-20220807163656818.png)

为了实现逻辑删除，使用数据库表中的`show_category`字段作为删除标记字段，它只有两个值可选，即0or1。

在表中当该字段默认值为1时表示展示该数据，否则为0时表示隐藏(已删除)该数据，另外，对于数据的物理删除，MybatisPlus自己默认生成的代码中就已经实现了，这里需要修改一下，将已有的删除方法改为逻辑删除。修改之后的代码如下：注意方法注释中的知识点。

> CategoryController中：

```java
/**
     * 删除
     * @RequestBody:获取请求体，必须发送POST请求
     * SpringMVC自动将请求体的数据（json），转为对应的对象
     */
@RequestMapping("/delete")
//@RequiresPermissions("product:category:delete")
public R delete(@RequestBody Long[] catIds){
    //categoryService.removeByIds(Arrays.asList(catIds));
    categoryService.removeMenuByIds(Arrays.asList(catIds));

    return R.ok();
}
```

替代之的是我们自己实现的`removeMenuByIds`方法，这是逻辑删除的实现，在对应的接口和实现类中进行具体实现。需要注意的是，尽管MybatisPlus默认生成的是物理删除方法，但是它也提供了如何实现逻辑删除的文档说明。[逻辑删除说明文档](https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95)

阅读文档，可将其实现步骤大致总结如下：

- 配置application.yml

```yaml
  global-config:
    db-config:
      id-type: auto
      logic-delete-value: 1
      logic-not-delete-value: 0
```

> 配置mybatis的全局配置文件，分别使用` logic-delete-value`和`logic-not-delete-value`来表示删除的标记位。

- 实体类字段上加上`@TableLogic`注解

```java
/**
	 * 是否显示[0-不显示，1显示]
	 */
@TableLogic(value = "1",delval = "0")
private Integer showStatus;
```

> 需要注意的是，官方默认将删除标记为1，不删除标记为0，这和我们数据库表字段的设计刚好相反，所以这里还需要再注解中使用valye和delval自定我们自己的规则。

#### 代码实现

将上述的逻辑删除的方法在实现类中的具体实现如下：

```java
/**
     * 分类菜单删除功能
     * @param asList 转为List
     */
@Override
public void removeMenuByIds(List<Long> asList) {
    //TODO  1、检查当前删除的菜单，是否被别的地方引用
    //逻辑删除
    baseMapper.deleteBatchIds(asList);
}
```

注意代码中的`//TODO`部分的说明，这意味着这个方法目前其实还不是全部完整的实现，还留了一个待办，就是在进行删除之前检查该分类菜单是否有被其他内容引用，由于目前尚未可知会被哪些功能引用，所以暂不作实现，留作代办。

之后如果需要实现的话，可以在IDEA中找到TODO列表，直接点击对应的待办即可快速定位到目标方法上。

![image-20220807165630094](https://images.waer.ltd/img/image-20220807165630094.png)

****

#### API测试

> 测试通过!,过程略。

#### 前后端联调

> category.vue全部代码：

```vue
<template>
  <div>
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
    >
       <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level<=2"
            type="text"
            size="mini"
            @click="() => append(data)">
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
  </div>
</template>

<script>
// 这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json 文件，图片文件等等）
// 例如：import  《组件名称》  from '《组件路径》 ';

export default {
  data () {
    return {
      menus: [],
      expandedKey:[],
      defaultProps: {
        children: 'children',
        label: 'name'
      }
    }
  },
  methods: {

    /**
     * 获取分类菜单
     */
    getMenus ()
    // eslint-disable-next-line no-lone-blocks,brace-style
      {
      this.$http({
        url: this.$http.adornUrl('product/category/list/tree'),
        method: 'get'
      }).then(({data}) => {
        console.log('获取到数据', data.data)
        this.menus = data.data;
      })
    },
    /**
     * 添加分类
     * @param data
     */
    append(data) {
      console.log("点击了添加",data)
    },

    /**
     * 移除分类
     * @param node
     * @param data
     */
    remove(node, data) {
      console.log("点击了删除",node,data)
      var ids = [data.catId]
      /* 删除之前的提示 */
      this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        /* 发送删除请求 */
        this.$http({
          url: this.$http.adornUrl('product/category/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({data}) => {
          /* 删除成功提示 */
          this.$message({
            showClose: true,
            message: '菜单已成功删除!',
            type: 'success'
          });
          //console.log("删除成功!")
          this.getMenus();
          /* 设置操作刷新后展开的结点 */
          this.expandedKey = [node.parent.data.catId];
        })
      }).catch(() => {
        /* 删除取消的提示 */
        this.$message({
          showClose: true,
          message: '操作已取消！'
        });
      });

    },
  },
}
</script>

<style scoped>
</style>

```

**注意几个点**

- 删除属于危险操作，应该给用户操作前提示
- 删除某个目录菜单之后应保持该目录刷新后处于展开状态。

#### 番外

经过前面两个API的开发发现，在前端操作中，有一部分的内容其实是可以抽象为模板的，如果你和我一样使用的是Webstorm进行前端开发，那么可以参考下面的方法将代码设置为模板，方便下次直接通过关键字+Tab按键即可快速使用模板。

![image-20220807170740722](https://images.waer.ltd/img/image-20220807170740722.png)

上面操作结束之后别忘记了点击【确认】或者【应用】，否则白给！

****

### 三级分类-添加单个分类菜单

#### 后端API

这节相对比较简单，在后端实现上来说，我们新增一个分类菜单，可以直接调用MybatisPlus生成的默认API即可完成添加。

> CategoryController

```java
/**
     * 保存新分类菜单
     * @param category 分类数据
     * @return R
     */
@RequestMapping("/save")
//@RequiresPermissions("product:category:save")
public R save(@RequestBody CategoryEntity category){
    categoryService.save(category);

    return R.ok();
}
```

啊这，关于添加的后端部分好像就 结束了哎，结束的有点尴尬。

#### 前后端联调

> 还是category.vue

```vue
<template>
  <div>
<!--树形控件开始-->
    <el-tree
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
    >
       <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
          <el-button
            v-if="node.level<=2"
            type="text"
            size="mini"
            @click="() => append(data)">
            Append
          </el-button>
          <el-button
            v-if="node.childNodes.length == 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            Delete
          </el-button>
        </span>
      </span>
    </el-tree>
    <!--树形控件结束-->
<!--对话框开始-->
    <el-dialog
      title="提示"
      :visible.sync="dialogVisible"
      width="30%"
      >
      <el-form :model="category">
        <el-form-item label="分类名称" >
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
    <el-button @click="dialogVisible = false">取 消</el-button>
    <el-button type="primary" @click="addCategory">确 定</el-button>
  </span>
    </el-dialog>
<!--对话框结束-->
  </div>
</template>

<script>
// 这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json 文件，图片文件等等）
// 例如：import  《组件名称》  from '《组件路径》 ';

export default {
  data () {
    return {
      category:{name:'',parentCid:0,catLevel:0,showStatus:1,sort:0},
      dialogVisible:false,
      menus: [],
      expandedKey:[],
      defaultProps: {
        children: 'children',
        label: 'name'
      }
    }
  },
  methods: {

    /**
     * 获取分类菜单
     */
    getMenus ()
    // eslint-disable-next-line no-lone-blocks,brace-style
      {
      this.$http({
        url: this.$http.adornUrl('product/category/list/tree'),
        method: 'get'
      }).then(({data}) => {
        console.log('获取到数据', data.data)
        this.menus = data.data;
      })
    },
    /**
     * 添加分类
     * @param data
     */
    append(data) {
      this.dialogVisible = true;
      /* 为表单项赋值 */
      this.category.parentCid = data.catId;
      this.category.catLevel = data.catLevel*1 + 1;
      /* 清空表单 */
      //this.category = {};
      /* 清除上一次添加输入的数据 */
    this.category.name = "";

      console.log("点击了添加",data)
    },

    /**
     * 添加分类的请求方法
     */
    addCategory(){
      console.log("提交的三级分类数据",this.category)
       this.$http({
               url: this.$http.adornUrl('product/category/save'),
               method: 'post',
               data: this.$http.adornData(this.category, false)
             }).then(({data}) => {
               // console.log("删除成功!")
               /* 添加成功提示 */
               this.$message({
                 showClose: true,
                 message: '菜单已成功添加!',
                 type: 'success'
               });
              /* 关闭对话框 */
              this.dialogVisible = false;
              /* 刷新菜单页面 */
              this.getMenus();
              /* 设置需要展开的菜单 */
              this.expandedKey = [this.category.parentCid];
             })
    },

    /**
     * 移除分类
     * @param node
     * @param data
     */
    remove(node, data) {
      console.log("点击了删除",node,data)
      var ids = [data.catId]
      /* 删除之前的提示 */
      this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        /* 发送删除请求 */
        this.$http({
          url: this.$http.adornUrl('product/category/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({data}) => {
          /* 删除成功提示 */
          this.$message({
            showClose: true,
            message: '菜单已成功删除!',
            type: 'success'
          });
          //console.log("删除成功!")
          this.getMenus();
          /* 设置操作刷新后展开的结点 */
          this.expandedKey = [node.parent.data.catId];
        })
      }).catch(() => {
        /* 删除取消的提示 */
        this.$message({
          showClose: true,
          message: '操作已取消！'
        });
      });

    },
  },
}
</script>
<style scoped>
</style>
```

> 前端代码不作讲解，具体请看注释。

**注意点**

每次弹出添加对话框时会携带上一次添加的数据问题已经解决。

#### API测试

> 测试通过！

启动项目，进行添加测试，这里出现了两个异常的BUG。

- 如果添加的是中文分类数据的话，添加之后显示是乱码。
- 当我们在一级目录下添加二级目录，再给二级目录添加子目录时会发现无法展开新添加的二级目录，或者直接添加不成功。
- 目前已知BUG就这些，下面附上解决方法。

**解决中文字符显示乱码问题**

> 这是由于我们再mysql链接时没有指定具体的数据编码导致，在application.yml中修改url如下：

```yaml
url: jdbc:mysql://xxxxxx:3307/gulimall_pms?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=UTC&serverTimezone=GMT%2B8
```

**解决二级菜单显示问题**

> 这是一个比较隐蔽的bug导致的，具体来说问题出现在一开始的递归查询分类数据的方法中，我们实体定义的分类ID为Long类型，但递归方法中比较判断是否为子目录时采用了`==`来判断，这是由弊端的，这种写法由于Long类型的缓存问题会导致在添加二级之后添加三级不会显示的问题，当数值超出类型范围时也会出现问题，解决办法就是使用`equals`来替代`==`作比较，或者使用`Objects.equals()`也是可以的。

具体修改`getChildrens()`方法

```java
private List<CategoryEntity> getChildrens(CategoryEntity root,List<CategoryEntity> all){

    List<CategoryEntity> children = all.stream().filter(categoryEntity -> {
        //这里不能用==来比较
        return categoryEntity.getParentCid().equals(root.getCatId());
    }).map(categoryEntity -> {
        //1、找到子菜单
        categoryEntity.setChildren(getChildrens(categoryEntity,all));
        return categoryEntity;
    }).sorted((menu1,menu2)->{
        //2、菜单的排序
        return (menu1.getSort()==null?0:menu1.getSort()) - (menu2.getSort()==null?0:menu2.getSort());
    }).collect(Collectors.toList());
    return children;
}
```

对于`listWithTree()`方法中的filter部分，也建议换成下面的方式：

```java
 .filter(categoryEntity -> categoryEntity.getParentCid().longValue() == 0)
```

至此本节收工。

****

### 三级分类-修改单个菜单

#### 功能分析

对分类数据的名称进行修改操作，同时也需要修改分类的图标和计量单位。

![image-20220808114655479](https://images.waer.ltd/img/image-20220808114655479.png)

这里主要涉及到dialog对话框的复用，后端API需要用到两个，分别是根据ID查询单个分类数据、分类数据的更新操作。总体没有太大难度。

#### 代码实现

后端API代码实现上，可以直接使用MybatisPlus的默认API，即：`update()`和`info()`

> CategoryController

```java
/**
     * 修改分类数据
     * @param category 分类数据
     * @return 修改之后的数据(R)
     */
@RequestMapping("/update")
//@RequiresPermissions("product:category:update")
public R update(@RequestBody CategoryEntity category){
    categoryService.updateCascade(category);
    return R.ok();
}
```

```java
    /**
     * 根据catId查询分类数据
     * @param catId 分类ID
     * @return 分类数据
     */
    @RequestMapping("/info/{catId}")
    //@RequiresPermissions("product:category:info")
    public R info(@PathVariable("catId") Long catId){
		CategoryEntity category = categoryService.getById(catId);
        return R.ok().put("data", category);
    }
```

具体的实现上其实就是简单的改和查。但是需要注意的是，我们在修改分类数据时，并不是(或者说不推荐)对整个`CategoryEntity`实体进行全量更新，而是更新必要的字段即可，具体就是分类数据的名称、图标、计量单位以及自增的字段，所以在请求API时传入的修改数据(JSON格式)中，应该提前做好分离处理，而不是直接提交一个category对象，关于具体的实现，这属于前端的业务，可以使用**对象解构**来实现。其实这一主要的任务量都集中在前端部分，有很多的细节需要处理。

#### API测试

> 测试通过!

#### 前后端联调

> category.vue全部代码

```vue
<template>
<div>
    <!--树形控件开始-->
    <el-tree
             :data="menus"
             :props="defaultProps"
             :expand-on-click-node="false"
             show-checkbox
             node-key="catId"
             :default-expanded-keys="expandedKey"
             >
        <span class="custom-tree-node" slot-scope="{ node, data }">
            <span>{{ node.label }}</span>
            <span>
                <!--添加按钮-->
                <el-button
                           v-if="node.level<=2"
                           type="text"
                           size="mini"
                           @click="() => append(data)">
                    添加
    </el-button>
                <!--修改按钮-->
                <el-button
                           type="text"
                           size="mini"
                           @click="() => edit(data)">
                    修改
    </el-button>
                <!--删除按钮-->
                <el-button
                           v-if="node.childNodes.length == 0"
                           type="text"
                           size="mini"
                           @click="() => remove(node, data)">
                    删除
    </el-button>
    </span>
    </span>
    </el-tree>
    <!--树形控件结束-->
    <!--对话框开始-->
    <el-dialog
               :title="title"
               :visible.sync="dialogVisible"
               width="30%"
               :close-on-click-modal = "false"
               >
        <el-form :model="category">
            <el-form-item label="分类名称" >
                <el-input v-model="category.name" autocomplete="off"></el-input>
    </el-form-item>

            <el-form-item label="分类图标" >
                <el-input v-model="category.icon" autocomplete="off"></el-input>
    </el-form-item>

            <el-form-item label="计量单位" >
                <el-input v-model="category.productUnit" autocomplete="off"></el-input>
    </el-form-item>
    </el-form>
        <span slot="footer" class="dialog-footer">
            <el-button @click="dialogVisible = false">取 消</el-button>
            <el-button type="primary" @click="submitData">确 定</el-button>
    </span>
    </el-dialog>
    <!--对话框结束-->
    </div>
</template>

<script>
    // 这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json 文件，图片文件等等）
    // 例如：import  《组件名称》  from '《组件路径》 ';

    export default {
        data () {
            return {
                title:"",
                dialogType:"",
                category:{
                    productUnit:'',
                    icon:'',
                    name:'',
                    parentCid:0,
                    catLevel:0,
                    showStatus:1,
                    sort:0,
                    catId:null
                },
                dialogVisible:false,
                menus: [],
                expandedKey:[],
                defaultProps: {
                    children: 'children',
                    label: 'name'
                }
            }
        },
        methods: {

            /**
     * 获取分类菜单
     */
            getMenus ()
            // eslint-disable-next-line no-lone-blocks,brace-style
            {
                this.$http({
                    url: this.$http.adornUrl('product/category/list/tree'),
                    method: 'get'
                }).then(({data}) => {
                    console.log('获取到数据', data.data)
                    this.menus = data.data;
                })
            },

            /**
     * 修改分类
     * @param data
     */
            edit(data) {
                this.title = "修改分类";
                this.dialogType  = "edit";
                console.log("需要修改的数据:",data);
                this.dialogVisible = true;
                /* 请求最新的结点数据 */
                this.$http({
                    url: this.$http.adornUrl(`product/category/info/${data.catId}`),
                    method: 'get'
                }).then(({data}) => {
                    this.category.name = data.data.name;
                    this.category.catId = data.data.catId;
                    this.category.icon = data.data.icon;
                    this.category.productUnit = data.data.productUnit;
                    /* 回显父ID */
                    this.category.parentCid = data.data.parentCid;
                    this.category.catLevel = data.data.catLevel;
                    this.category.sort = data.data.sort;
                    this.category.showStatus = data.data.showStatus;
                    console.log('获取到数据', data.data)
                })
            },


            /**
     * 添加分类
     * @param data
     */
            append(data) {
                this.title = "添加分类";
                this.dialogType = "add";
                this.dialogVisible = true;
                /* 为表单项赋值 */
                this.category.parentCid = data.catId;
                this.category.catLevel = data.catLevel*1 + 1;
                /* 清空表单 */
                //this.category = {};
                /* 清除上一次添加输入的数据 */
                this.category.name = "";
                this.category.catId = null;
                this.category.icon = "";
                this.category.productUnit = "";
                this.category.showStatus = 1;
                this.category.sort = 0;
                console.log("点击了添加",data)
            },

            /**
     * 添加分类的请求方法
     */
            addCategory(){
                console.log("提交的三级分类数据",this.category)
                this.$http({
                    url: this.$http.adornUrl('product/category/save'),
                    method: 'post',
                    data: this.$http.adornData(this.category, false)
                }).then(({data}) => {
                    // console.log("删除成功!")
                    /* 添加成功提示 */
                    this.$message({
                        showClose: true,
                        message: '菜单已成功添加!',
                        type: 'success'
                    });
                    /* 关闭对话框 */
                    this.dialogVisible = false;
                    /* 刷新菜单页面 */
                    this.getMenus();
                    /* 设置需要展开的菜单 */
                    this.expandedKey = [this.category.parentCid];
                })
            },

            /**
     * 移除分类
     * @param node
     * @param data
     */
            remove(node, data) {
                console.log("点击了删除",node,data)
                var ids = [data.catId]
                /* 删除之前的提示 */
                this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
                    confirmButtonText: '确定',
                    cancelButtonText: '取消',
                    type: 'warning'
                }).then(() => {
                    /* 发送删除请求 */
                    this.$http({
                        url: this.$http.adornUrl('product/category/delete'),
                        method: 'post',
                        data: this.$http.adornData(ids, false)
                    }).then(({data}) => {
                        /* 删除成功提示 */
                        this.$message({
                            showClose: true,
                            message: '菜单已成功删除!',
                            type: 'success'
                        });
                        //console.log("删除成功!")
                        this.getMenus();
                        /* 设置操作刷新后展开的结点 */
                        this.expandedKey = [node.parent.data.catId];
                    })
                }).catch(() => {
                    /* 删除取消的提示 */
                    this.$message({
                        showClose: true,
                        message: '操作已取消！'
                    });
                });
            },
            /**
     * 修改请求
     */
            editCategory() {
                var {catId,name,icon,productUnit} = this.category;
                //var data = {catId,name,icon,productUnit};
                this.$http({
                    url: this.$http.adornUrl('product/category/update'),
                    method: 'post',
                    data: this.$http.adornData({catId,name,icon,productUnit}, false)
                }).then(({data}) => {
                    console.log("修改成功!")
                    this.$message({
                        showClose: true,
                        message: '菜单已成功修改!',
                        type: 'success'
                    });
                    /* 关闭对话框 */
                    this.dialogVisible = false;
                    /* 刷新菜单页面 */
                    this.getMenus();
                    /* 设置需要展开的菜单 */
                    this.expandedKey = [this.category.parentCid];
                });
            },

            /**
     * 提交对话框类型判断
     */
            submitData() {
                if(this.dialogType === "add") {
                    this.addCategory();
                }
                if(this.dialogType === "edit") {
                    this.editCategory();
                }
            }
        },
        // 生命周期 - 创建完成（可以访问当前this 实例）
        created () {
            this.getMenus()
        },
    }
</script>

<style scoped>
</style>
```

联调通过！业务功能可用。

****

### 三级分类-菜单拖拽功能

#### 功能分析

结合element-ui实现分类菜单的拖拽功能，实现拖拽数据的后端修改API。

菜单拖拽功能，主要的实现方法在于前端的处理，而对于后端，其实就是将拖拽之后拖拽之后分类数据的变化写入数据库中。

#### 代码实现

> categoryController

```java
/**
     * 批量修改分类数据(拖拽功能)
     * @param category
     * @return category
     */
@RequestMapping("/update/sort")
//@RequiresPermissions("product:category:update")
public R updateSort(@RequestBody CategoryEntity[] category){
    categoryService.updateBatchById(Arrays.asList(category));
    return R.ok();
}
```

整个API其实就是对数据的更新操作，以上就是后端的全部内容。

#### 前后端联调

> category.vue

```vue
<template>
<div>
    <el-switch
               v-model="draggable"
               active-text="开启拖拽"
               inactive-text="关闭拖拽">
    </el-switch>
    <!--树形控件开始-->
    <el-tree
             :data="menus"
             :props="defaultProps"
             :expand-on-click-node="false"
             show-checkbox
             node-key="catId"
             :default-expanded-keys="expandedKey"
             :draggable="draggable"
             :allow-drop="allowDrop"
             @node-drop="handleDrop"
             >
        <span class="custom-tree-node" slot-scope="{ node, data }">
            <span>{{ node.label }}</span>
            <span>
                <!--添加按钮-->
                <el-button
                           v-if="node.level<=2"
                           type="text"
                           size="mini"
                           @click="() => append(data)">
                    添加
    </el-button>
                <!--修改按钮-->
                <el-button
                           type="text"
                           size="mini"
                           @click="() => edit(data)">
                    修改
    </el-button>
                <!--删除按钮-->
                <el-button
                           v-if="node.childNodes.length === 0"
                           type="text"
                           size="mini"
                           @click="() => remove(node, data)">
                    删除
    </el-button>
    </span>
    </span>
    </el-tree>
    <!--树形控件结束-->
    <!--对话框开始-->
    <el-dialog
               :title="title"
               :visible.sync="dialogVisible"
               width="30%"
               :close-on-click-modal="false"
               >
        <el-form :model="category">
            <el-form-item label="分类名称">
                <el-input v-model="category.name" autocomplete="off"></el-input>
    </el-form-item>

            <el-form-item label="分类图标">
                <el-input v-model="category.icon" autocomplete="off"></el-input>
    </el-form-item>

            <el-form-item label="计量单位">
                <el-input v-model="category.productUnit" autocomplete="off"></el-input>
    </el-form-item>
    </el-form>
        <span slot="footer" class="dialog-footer">
            <el-button @click="dialogVisible = false">取 消</el-button>
            <el-button type="primary" @click="submitData">确 定</el-button>
    </span>
    </el-dialog>
    <!--对话框结束-->
    </div>
</template>

<script>
    // 这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json 文件，图片文件等等）
    // 例如：import  《组件名称》  from '《组件路径》 ';

    export default {
        data () {
            return {
                draggable:false,
                updateNodes: [],
                maxLevel: 0,
                title: '',
                dialogType: '',
                category: {
                    productUnit: '',
                    icon: '',
                    name: '',
                    parentCid: 0,
                    catLevel: 0,
                    showStatus: 1,
                    sort: 0,
                    catId: null
                },
                dialogVisible: false,
                menus: [],
                expandedKey: [],
                defaultProps: {
                    children: 'children',
                    label: 'name'
                }
            }
        },
        methods: {

            /**
     * 获取分类菜单
     */
            getMenus ()
            // eslint-disable-next-line no-lone-blocks,brace-style
            {
                this.$http({
                    url: this.$http.adornUrl('product/category/list/tree'),
                    method: 'get'
                }).then(({data}) => {
                    console.log('获取到数据', data.data)
                    this.menus = data.data
                })
            },

            /**
     * 修改分类
     * @param data
     */
            edit (data) {
                this.title = '修改分类'
                this.dialogType = 'edit'
                console.log('需要修改的数据:', data)
                this.dialogVisible = true
                /* 请求最新的结点数据 */
                this.$http({
                    url: this.$http.adornUrl(`product/category/info/${data.catId}`),
                    method: 'get'
                }).then(({data}) => {
                    this.category.name = data.data.name
                    this.category.catId = data.data.catId
                    this.category.icon = data.data.icon
                    this.category.productUnit = data.data.productUnit
                    /* 回显父ID */
                    this.category.parentCid = data.data.parentCid
                    this.category.catLevel = data.data.catLevel
                    this.category.sort = data.data.sort
                    this.category.showStatus = data.data.showStatus
                    console.log('获取到数据', data.data)
                })
            },

            /**
     * 添加分类
     * @param data
     */
            append (data) {
                this.title = '添加分类'
                this.dialogType = 'add'
                this.dialogVisible = true
                /* 为表单项赋值 */
                this.category.parentCid = data.catId
                this.category.catLevel = data.catLevel * 1 + 1
                /* 清空表单 */
                //this.category = {};
                /* 清除上一次添加输入的数据 */
                this.category.name = ''
                this.category.catId = null
                this.category.icon = ''
                this.category.productUnit = ''
                this.category.showStatus = 1
                this.category.sort = 0
                console.log('点击了添加', data)
            },

            /**
     * 添加分类的请求方法
     */
            addCategory(){
                console.log("提交的三级分类数据",this.category)
                this.$http({
                    url: this.$http.adornUrl('product/category/save'),
                    method: 'post',
                    data: this.$http.adornData(this.category, false)
                }).then(({data}) => {
                    // console.log("删除成功!")
                    /* 添加成功提示 */
                    this.$message({
                        showClose: true,
                        message: '菜单已成功添加!',
                        type: 'success'
                    });
                    /* 关闭对话框 */
                    this.dialogVisible = false;
                    /* 刷新菜单页面 */
                    this.getMenus();
                    /* 设置需要展开的菜单 */
                    this.expandedKey = [this.category.parentCid];
                })
            },

            /**
     * 移除分类
     * @param node
     * @param data
     */
            remove(node, data) {
                console.log("点击了删除",node,data)
                var ids = [data.catId]
                /* 删除之前的提示 */
                this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
                    confirmButtonText: '确定',
                    cancelButtonText: '取消',
                    type: 'warning'
                }).then(() => {
                    /* 发送删除请求 */
                    this.$http({
                        url: this.$http.adornUrl('product/category/delete'),
                        method: 'post',
                        data: this.$http.adornData(ids, false)
                    }).then(({data}) => {
                        /* 删除成功提示 */
                        this.$message({
                            showClose: true,
                            message: '菜单已成功删除!',
                            type: 'success'
                        });
                        //console.log("删除成功!")
                        this.getMenus();
                        /* 设置操作刷新后展开的结点 */
                        this.expandedKey = [node.parent.data.catId]
                    })
                }).catch(() => {
                    /* 删除取消的提示 */
                    this.$message({
                        showClose: true,
                        message: '操作已取消！'
                    })
                });
            },
            /**
     * 修改请求
     */
            editCategory () {
                var {catId, name, icon, productUnit} = this.category
                //var data = {catId,name,icon,productUnit};
                this.$http({
                    url: this.$http.adornUrl('product/category/update'),
                    method: 'post',
                    data: this.$http.adornData({catId, name, icon, productUnit}, false)
                }).then(({data}) => {
                    console.log('修改成功!')
                    this.$message({
                        showClose: true,
                        message: '菜单已成功修改!',
                        type: 'success'
                    })
                    /* 关闭对话框 */
                    this.dialogVisible = false
                    /* 刷新菜单页面 */
                    this.getMenus()
                    /* 设置需要展开的菜单 */
                    this.expandedKey = [this.category.parentCid]
                })
            },

            /**
     * 提交对话框类型判断
     */
            submitData () {
                if (this.dialogType === 'add') {
                    this.addCategory()
                }
                if (this.dialogType === 'edit') {
                    this.editCategory()
                }
            },
            /* 可知结点拖拽逻辑 */
            allowDrop (draggingNode, dropNode, type) {
                //1.被拖动的当前结点以及所在的父结点总层数不能大于3

                //1.1被托动的当前结点总层数
                console.log('allDrop', draggingNode, dropNode, type)
                this.countNodeLevel(draggingNode.data)
                //当前拖动的节点+父节点所在的深度不大于3即可
                let deep = this.maxLevel - draggingNode.data.catLevel + 1
                console.log('深度:', deep)
                if (type === 'inner') {
                    return (deep + dropNode.level) <= 3
                } else {
                    return (deep + dropNode.parent.level) <= 3
                }
            },
            /**
     * 计算当前结点的总层数
     * @param node
     */
            countNodeLevel (node) {
                //找到所有子节点，求出最大深度
                if (node.children != null && node.children.length > 0) {
                    for (let i = 0; i < node.children.length; i++) {
                        if (node.children[i].catLevel > this.maxLevel) {
                            this.maxLevel = node.children[i].catLevel
                        }
                        //递归
                        this.countNodeLevel(node.children[i])
                    }
                }
            },
            handleDrop (draggingNode, dropNode, dropType, ev) {
                console.log('tree drop: ', dropNode.label, dropType)
                //1.当前节点最新的父节点ID
                let pCid = 0
                let sibings = null
                if (dropType === 'before' || dropType === 'after') {
                    pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
                    sibings = dropNode.parent.childNodes
                } else {
                    pCid = dropNode.data.catId
                    sibings = dropNode.childNodes
                }

                //2.当前拖拽节点的最新顺序
                for (let i = 0; i < sibings.length; i++) {
                    if (sibings[i].data.catId === draggingNode.data.catId) {
                        //如果遍历的是当前正在拖拽的节点
                        let catLevel = draggingNode.level
                        if (sibings[i].level !== draggingNode.level) {
                            //当前节点的层级发生变化
                            catLevel = sibings[i].level
                            //修改子节点的层级
                            this.updateChildNodeLevel(sibings[i])
                        }
                        this.updateNodes.push({catId: sibings[i].data.catId, sort: i, parentCid: pCid, catLevel: catLevel})
                    } else {
                        this.updateNodes.push({catId: sibings[i].data.catId, sort: i})
                    }
                }

                //3.当前拖拽节点的最新层级
                console.log('updateNodes:', this.updateNodes)
                this.$http({
                    url: this.$http.adornUrl('product/category/update/sort'),
                    method: 'post',
                    data: this.$http.adornData(this.updateNodes, false)
                }).then(({data}) => {
                    this.$message({
                        showClose: true,
                        message: '菜单顺序等已成功修改!',
                        type: 'success'
                    })
                    /* 刷新菜单页面 */
                    this.getMenus()
                    /* 设置需要展开的菜单 */
                    this.expandedKey = [pCid]
                    /* 初始化数据 */
                    this.updateNodes = []
                    this.maxLevel = 0
                })
            },

            /**
     * 更新子节点的层级
     * @param node
     */
            updateChildNodeLevel (node) {
                if (node.childNodes.length > 0) {
                    for (let i = 0; i < node.childNodes.length; i++) {
                        var cNode = node.childNodes[i].data
                        this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
                        this.updateChildNodeLevel(node.childNodes[i])
                    }
                }
            }
        },
        // 生命周期 - 创建完成（可以访问当前this 实例）
        created () {
            this.getMenus()
        },
    }
</script>
<style scoped>
</style>
```

****

### 三级分类-批量拖拽效果&批量删除

### 代码实现

> 由于这里并没有新的后端逻辑，直接是用的默认API，所以贴一下前端代码好了。

> category.vue

```vue
<template>
  <div>
    <el-switch
      v-model="draggable"
      active-text="开启拖拽"
      inactive-text="关闭拖拽">

    </el-switch>
    <el-button
      type="primary"
      round
      size="mini"
      v-if="draggable"
      @click="batchSave">
    批量保存
  </el-button>

    <el-button
      type="danger"
      round
      size="mini"
      @click="batchDelete">
      批量删除
    </el-button>
<!--树形控件开始-->
    <el-tree
      ref="menuTree"
      :data="menus"
      :props="defaultProps"
      :expand-on-click-node="false"
      show-checkbox
      node-key="catId"
      :default-expanded-keys="expandedKey"
      :draggable="draggable"
      :allow-drop="allowDrop"
      @node-drop="handleDrop"
    >
       <span class="custom-tree-node" slot-scope="{ node, data }">
        <span>{{ node.label }}</span>
        <span>
<!--添加按钮-->
          <el-button
            v-if="node.level<=2"
            type="text"
            size="mini"
            @click="() => append(data)">
            添加
          </el-button>
          <!--修改按钮-->
        <el-button
          type="text"
          size="mini"
          @click="() => edit(data)">
          修改
        </el-button>
          <!--删除按钮-->
          <el-button
            v-if="node.childNodes.length === 0"
            type="text"
            size="mini"
            @click="() => remove(node, data)">
            删除
          </el-button>
        </span>
      </span>
    </el-tree>
    <!--树形控件结束-->
<!--对话框开始-->
    <el-dialog
      :title="title"
      :visible.sync="dialogVisible"
      width="30%"
      :close-on-click-modal="false"
      >
      <el-form :model="category">
        <el-form-item label="分类名称">
          <el-input v-model="category.name" autocomplete="off"></el-input>
        </el-form-item>

        <el-form-item label="分类图标">
          <el-input v-model="category.icon" autocomplete="off"></el-input>
        </el-form-item>

        <el-form-item label="计量单位">
          <el-input v-model="category.productUnit" autocomplete="off"></el-input>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
    <el-button @click="dialogVisible = false">取 消</el-button>
    <el-button type="primary" @click="submitData">确 定</el-button>
  </span>
    </el-dialog>
<!--对话框结束-->
  </div>
</template>

<script>
// 这里可以导入其他文件（比如：组件，工具 js，第三方插件 js，json 文件，图片文件等等）
// 例如：import  《组件名称》  from '《组件路径》 ';

export default {
  data () {
    return {
      pCid:[],
      draggable:false,
      updateNodes: [],
      maxLevel: 0,
      title: '',
      dialogType: '',
      category: {
        productUnit: '',
        icon: '',
        name: '',
        parentCid: 0,
        catLevel: 0,
        showStatus: 1,
        sort: 0,
        catId: null
      },
      dialogVisible: false,
      menus: [],
      expandedKey: [],
      defaultProps: {
        children: 'children',
        label: 'name'
      }
    }
  },
  methods: {

    /**
     * 获取分类菜单
     */
    getMenus ()
    // eslint-disable-next-line no-lone-blocks,brace-style
    {
      this.$http({
        url: this.$http.adornUrl('product/category/list/tree'),
        method: 'get'
      }).then(({data}) => {
        console.log('获取到数据', data.data)
        this.menus = data.data
      })
    },

    /**
     * 修改分类
     * @param data
     */
    edit (data) {
      this.title = '修改分类'
      this.dialogType = 'edit'
      console.log('需要修改的数据:', data)
      this.dialogVisible = true
      /* 请求最新的结点数据 */
      this.$http({
        url: this.$http.adornUrl(`product/category/info/${data.catId}`),
        method: 'get'
      }).then(({data}) => {
        this.category.name = data.data.name
        this.category.catId = data.data.catId
        this.category.icon = data.data.icon
        this.category.productUnit = data.data.productUnit
        /* 回显父ID */
        this.category.parentCid = data.data.parentCid
        this.category.catLevel = data.data.catLevel
        this.category.sort = data.data.sort
        this.category.showStatus = data.data.showStatus
        console.log('获取到数据', data.data)
      })
    },

    /**
     * 添加分类
     * @param data
     */
    append (data) {
      this.title = '添加分类'
      this.dialogType = 'add'
      this.dialogVisible = true
      /* 为表单项赋值 */
      this.category.parentCid = data.catId
      this.category.catLevel = data.catLevel * 1 + 1
      /* 清空表单 */
      //this.category = {};
      /* 清除上一次添加输入的数据 */
      this.category.name = ''
      this.category.catId = null
      this.category.icon = ''
      this.category.productUnit = ''
      this.category.showStatus = 1
      this.category.sort = 0
      console.log('点击了添加', data)
    },

    /**
     * 添加分类的请求方法
     */
    addCategory(){
      console.log("提交的三级分类数据",this.category)
       this.$http({
               url: this.$http.adornUrl('product/category/save'),
               method: 'post',
               data: this.$http.adornData(this.category, false)
             }).then(({data}) => {
               // console.log("删除成功!")
               /* 添加成功提示 */
               this.$message({
                 showClose: true,
                 message: '菜单已成功添加!',
                 type: 'success'
               });
              /* 关闭对话框 */
              this.dialogVisible = false;
              /* 刷新菜单页面 */
              this.getMenus();
              /* 设置需要展开的菜单 */
              this.expandedKey = [this.category.parentCid];
             })
    },

    /**
     * 移除分类
     * @param node
     * @param data
     */
    remove(node, data) {
      console.log("点击了删除",node,data)
      var ids = [data.catId]
      /* 删除之前的提示 */
      this.$confirm(`是否删除【${data.name}】菜单?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        /* 发送删除请求 */
        this.$http({
          url: this.$http.adornUrl('product/category/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({data}) => {
          /* 删除成功提示 */
          this.$message({
            showClose: true,
            message: '菜单已成功删除!',
            type: 'success'
          });
          //console.log("删除成功!")
          this.getMenus();
          /* 设置操作刷新后展开的结点 */
          this.expandedKey = [node.parent.data.catId]
        })
      }).catch(() => {
        /* 删除取消的提示 */
        this.$message({
          showClose: true,
          message: '操作已取消！'
        })
      });
    },
    /**
     * 修改请求
     */
    editCategory () {
      var {catId, name, icon, productUnit} = this.category
      //var data = {catId,name,icon,productUnit};
      this.$http({
        url: this.$http.adornUrl('product/category/update'),
        method: 'post',
        data: this.$http.adornData({catId, name, icon, productUnit}, false)
      }).then(({data}) => {
        console.log('修改成功!')
        this.$message({
          showClose: true,
          message: '菜单已成功修改!',
          type: 'success'
        })
        /* 关闭对话框 */
        this.dialogVisible = false
        /* 刷新菜单页面 */
        this.getMenus()
        /* 设置需要展开的菜单 */
        this.expandedKey = [this.category.parentCid]
      })
    },

    /**
     * 提交对话框类型判断
     */
    submitData () {
      if (this.dialogType === 'add') {
        this.addCategory()
      }
      if (this.dialogType === 'edit') {
        this.editCategory()
      }
    },
    /* 可知结点拖拽逻辑 */
    allowDrop (draggingNode, dropNode, type) {
      //1.被拖动的当前结点以及所在的父结点总层数不能大于3

      //1.1被托动的当前结点总层数
      console.log('allDrop', draggingNode, dropNode, type)
      this.countNodeLevel(draggingNode)
      //当前拖动的节点+父节点所在的深度不大于3即可
      let deep = Math.abs(this.maxLevel - draggingNode.level) + 1
      console.log('深度:', deep)
      if (type === 'inner') {
        return (deep + dropNode.level) <= 3
      } else {
        return (deep + dropNode.parent.level) <= 3
      }
    },
    /**
     * 计算当前结点的总层数
     * @param node
     */
    countNodeLevel (node) {
      //找到所有子节点，求出最大深度
      if (node.childNodes != null && node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          if (node.childNodes[i].level > this.maxLevel) {
            this.maxLevel = node.childNodes[i].level
          }
          //递归
          this.countNodeLevel(node.childNodes[i])
        }
      }
    },
    handleDrop (draggingNode, dropNode, dropType, ev) {
      console.log('tree drop: ', dropNode.label, dropType)
      //1.当前节点最新的父节点ID
      let pCid = 0
      let sibings = null
      if (dropType === 'before' || dropType === 'after') {
        pCid = dropNode.parent.data.catId === undefined ? 0 : dropNode.parent.data.catId
        sibings = dropNode.parent.childNodes
      } else {
        pCid = dropNode.data.catId
        sibings = dropNode.childNodes
      }
      this.pCid.push(pCid);

      //2.当前拖拽节点的最新顺序
      for (let i = 0; i < sibings.length; i++) {
        if (sibings[i].data.catId === draggingNode.data.catId) {
          //如果遍历的是当前正在拖拽的节点
          let catLevel = draggingNode.level
          if (sibings[i].level !== draggingNode.level) {
            //当前节点的层级发生变化
            catLevel = sibings[i].level
            //修改子节点的层级
            this.updateChildNodeLevel(sibings[i])
          }
          this.updateNodes.push({catId: sibings[i].data.catId, sort: i, parentCid: pCid, catLevel: catLevel})
        } else {
          this.updateNodes.push({catId: sibings[i].data.catId, sort: i})
        }
      }

      //3.当前拖拽节点的最新层级
      console.log('updateNodes:', this.updateNodes)
    },

    /**
     * 更新子节点的层级
     * @param node
     */
    updateChildNodeLevel (node) {
      if (node.childNodes.length > 0) {
        for (let i = 0; i < node.childNodes.length; i++) {
          var cNode = node.childNodes[i].data
          this.updateNodes.push({catId: cNode.catId, catLevel: node.childNodes[i].level})
          this.updateChildNodeLevel(node.childNodes[i])
        }
      }
    },
    /**
     * 批量保存
     */
    batchSave () {
      this.$http({
        url: this.$http.adornUrl('product/category/update/sort'),
        method: 'post',
        data: this.$http.adornData(this.updateNodes, false)
      }).then(({data}) => {
        this.$message({
          showClose: true,
          message: '菜单顺序等已成功修改!',
          type: 'success'
        })
        /* 刷新菜单页面 */
        this.getMenus()
        /* 设置需要展开的菜单 */
        this.expandedKey = this.pCid
        /* 初始化数据 */
        this.updateNodes = []
        this.maxLevel = 0
      })
    },
    /**
     * 批量删除
     */
    batchDelete (){
      let catIds = [];
      let checkedNodes = this.$refs.menuTree.getCheckedNodes();
      for(let i=0;i<checkedNodes.length;i++) {
        catIds.push(checkedNodes[i].catId);
      }
      this.$confirm(`是否批量删除【${catIds}】菜单?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(()=>{
         this.$http({
                 url: this.$http.adornUrl('product/category/delete'),
                 method: 'post',
                 data: this.$http.adornData(catIds, false)
               }).then(({data}) => {
                    this.$message({
                     showClose: true,
                     message: '菜单批量删除成功!',
                     type: 'success'
                   });
                    //刷新菜单
                    this.getMenus();
               })
      })
      console.log("被选中的元素:" ,checkedNodes);
    }
  },
  // 生命周期 - 创建完成（可以访问当前this 实例）
  created () {
    this.getMenus()
  },
}
</script>

<style scoped>
</style>

```



****

## 品牌管理API开发

### 品牌信息CURD-文件上传

#### 功能分析

关于品牌数据的增删改查，直接使用默认的API即可，前端页面也可以通过renren的代码生成器直接创建再加以修改。

这节的主要内容是文件上传，具体下来就是品牌logo的图片文件上传的处理。

图片存储使用阿里云的OSS对象存储服务，所以再具体的实现上，可以参考官方提供的API开发文档。

对于前端部分，使用element-ui的自带的上传组件进行封装。

#### 代码实现

> 这里主要集中记录一下文件上传的实现部分。

在代码开始之前，需要先在阿里云开通OSS存储服务，创建一个Bucket来单独存储该项目中的品牌文件数据。

具体的代码部分参考官方API:https://help.aliyun.com/document_detail/31947.html?spm=5176.87240.400427.2.141046142PJcFu

我们需要抽取一个独立的服务来作为第三方API服务的模块，之后所有涉及第三方API的内容都会集中放在该模块中并通过nacos管理。

- 导入相应的依赖

  > 在pom.xml中导入common依赖并排除mybatis-plus的部分

```xml
<dependency>
    <groupId>com.atguigu.gulimall</groupId>
    <artifactId>gulimall-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <exclusions>
        <exclusion>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alicloud-oss</artifactId>
</dependency>

 <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.1.0.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

- application.yml

```yaml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    alicloud:
      access-key: LTAI5t7EVdwsoAxhBYingsh
      secret-key: ZiA9SgMwQjvREG5GrPnkHKntZP
      oss:
        endpoint: oss-cn-hangzhou.aliyuncs.com
        bucket: gulimall-waer
  application:
    name: gulimall-third-party
server:
  port: 30000
```

- bootstrap.properties

```properties
spring.application.name=gulimall-third-party
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=fd757a50-bc0b-4e7d-8106-c1dd932f71a2
spring.cloud.nacos.config.ext-config[0].data-id=oss.yml
spring.cloud.nacos.config.ext-config[0].group=DEFAULT_GROUP
spring.cloud.nacos.config.ext-config[0].refresh=true
```

- 创建一个controller方法，用来处理文件上传服务。

```java
package com.atguigu.gulimall.thirdparty.controller;

import com.aliyun.oss.OSS;
import com.aliyun.oss.common.utils.BinaryUtil;
import com.aliyun.oss.model.MatchMode;
import com.aliyun.oss.model.PolicyConditions;
import com.atguigu.common.utils.R;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

@RestController
public class OssController {

    @Autowired
    OSS ossClient;

    @Value("${spring.cloud.alicloud.oss.endpoint}")
    private String endpoint;
    @Value("${spring.cloud.alicloud.oss.bucket}")
    private String bucket;

    @Value("${spring.cloud.alicloud.access-key}")
    private String accessId;

    /**
     * 上传文件请求API
     * @return R
     */
    @RequestMapping("/oss/policy")
    public R policy() {
        /*host的格式为 bucketname.endpoint*/
        String host = "https://" + bucket + "." + endpoint;  
        /*callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。*/
       /*String callbackUrl = "http://88.88.88.88:8888";*/
        String format = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
        /*用户上传文件时指定的前缀。*/
        String dir = format + "/";  

        Map<String, String> respMap = null;
        try {
            long expireTime = 30;
            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;
            Date expiration = new Date(expireEndTime);
            PolicyConditions policyConds = new PolicyConditions();
            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);
            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);

            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);
            byte[] binaryData = postPolicy.getBytes("utf-8");
            String encodedPolicy = BinaryUtil.toBase64String(binaryData);
            String postSignature = ossClient.calculatePostSignature(postPolicy);

            respMap = new LinkedHashMap<String, String>();
            respMap.put("accessid", accessId);
            respMap.put("policy", encodedPolicy);
            respMap.put("signature", postSignature);
            respMap.put("dir", dir);
            respMap.put("host", host);
            respMap.put("expire", String.valueOf(expireEndTime / 1000));
            // respMap.put("expire", formatISO8601Date(expiration));


        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        return R.ok().put("data",respMap);
    }
}
```

同样，还需要再网关处将对于的请求路径进行替换和转发。

```properties
        - id: third_party_route
          uri: lb://gulimall-third-party
          predicates:
              - Path=/api/thirdparty/**
          filters:
              - RewritePath=/api/thirdparty/(?<segment>.*),/$\{segment}
```

#### API测试

> 通过！





#### 前后端联调

- brand.vue

```vue
<template>
  <div class="mod-config">
    <el-form :inline="true" :model="dataForm" @keyup.enter.native="getDataList()">
      <el-form-item>
        <el-input v-model="dataForm.key" placeholder="参数名" clearable></el-input>
      </el-form-item>
      <el-form-item>
        <el-button @click="getDataList()">查询</el-button>
        <el-button v-if="isAuth('product:brand:save')" type="primary" @click="addOrUpdateHandle()">新增</el-button>
        <el-button v-if="isAuth('product:brand:delete')" type="danger" @click="deleteHandle()"
                   :disabled="dataListSelections.length <= 0">批量删除
        </el-button>
      </el-form-item>
    </el-form>
    <el-table
      :data="dataList"
      border
      v-loading="dataListLoading"
      @selection-change="selectionChangeHandle"
      style="width: 100%;">
      <el-table-column
        type="selection"
        header-align="center"
        align="center"
        width="50">
      </el-table-column>
      <el-table-column
        prop="brandId"
        header-align="center"
        align="center"
        label="品牌id">
      </el-table-column>
      <el-table-column
        prop="name"
        header-align="center"
        align="center"
        label="品牌名">
      </el-table-column>
      <el-table-column
        prop="logo"
        header-align="center"
        align="center"
        label="品牌logo地址">
        <template slot-scope="scope">
          <!--          <el-image-->
          <!--            style="width: 100px; height: 80px"-->
          <!--            :src="scope.row.logo"-->
          <!--            :fit="fill">-->
          <!--          </el-image>-->
          <img :src="scope.row.logo" style="width: 100px; height: 80px"/>
        </template>
      </el-table-column>
      <el-table-column
        prop="descript"
        header-align="center"
        align="center"
        label="介绍">
      </el-table-column>
      <el-table-column
        prop="showStatus"
        header-align="center"
        align="center"
        label="显示状态">
        <template slot-scope="scope">
          <el-switch
            :active-value="1"
            :inactive-value="0"
            @change="updateBrandStatus(scope.row)"
            v-model="scope.row.showStatus"
            active-color="#13ce66"
            inactive-color="#ff4949"

          >
          </el-switch>
        </template>
      </el-table-column>
      <el-table-column
        prop="firstLetter"
        header-align="center"
        align="center"
        label="检索首字母">
      </el-table-column>
      <el-table-column
        prop="sort"
        header-align="center"
        align="center"
        label="排序">
      </el-table-column>
      <el-table-column
        fixed="right"
        header-align="center"
        align="center"
        width="150"
        label="操作">
        <template slot-scope="scope">
          <el-button type="text" size="small" @click="addOrUpdateHandle(scope.row.brandId)">修改</el-button>
          <el-button type="text" size="small" @click="deleteHandle(scope.row.brandId)">删除</el-button>
        </template>
      </el-table-column>
    </el-table>
    <el-pagination
      @size-change="sizeChangeHandle"
      @current-change="currentChangeHandle"
      :current-page="pageIndex"
      :page-sizes="[10, 20, 50, 100]"
      :page-size="pageSize"
      :total="totalPage"
      layout="total, sizes, prev, pager, next, jumper">
    </el-pagination>
    <!-- 弹窗, 新增 / 修改 -->
    <add-or-update v-if="addOrUpdateVisible" ref="addOrUpdate" @refreshDataList="getDataList"></add-or-update>
  </div>
</template>

<script>
import AddOrUpdate from './brand-add-or-update'

export default {
  data () {
    return {
      dataForm: {
        key: ''
      },
      dataList: [],
      pageIndex: 1,
      pageSize: 10,
      totalPage: 0,
      dataListLoading: false,
      dataListSelections: [],
      addOrUpdateVisible: false
    }
  },
  components: {
    AddOrUpdate
  },
  activated () {
    this.getDataList()
  },
  methods: {

    /**
     * 更新数据行显示状态
     * @param status
     */
    updateBrandStatus (data) {
      console.log('显示状态', data)
      /* 修改请求 */
      let {brandId, showStatus} = data
      this.$http({
        url: this.$http.adornUrl('product/brand/update/status'),
        method: 'post',
        data: this.$http.adornData({brandId, showStatus}, false)
      }).then(({data}) => {
        // console.log("删除成功!")
        this.$message({
          type: 'success',
          message: '状态更新成功!'
        })
      })
    },

    // 获取数据列表
    getDataList () {
      this.dataListLoading = true
      this.$http({
        url: this.$http.adornUrl('product/brand/list'),
        method: 'get',
        params: this.$http.adornParams({
          'page': this.pageIndex,
          'limit': this.pageSize,
          'key': this.dataForm.key
        })
      }).then(({data}) => {
        if (data && data.code === 0) {
          this.dataList = data.page.list
          this.totalPage = data.page.totalCount
        } else {
          this.dataList = []
          this.totalPage = 0
        }
        this.dataListLoading = false
      })
    },
    // 每页数
    sizeChangeHandle (val) {
      this.pageSize = val
      this.pageIndex = 1
      this.getDataList()
    },
    // 当前页
    currentChangeHandle (val) {
      this.pageIndex = val
      this.getDataList()
    },
    // 多选
    selectionChangeHandle (val) {
      this.dataListSelections = val
    },
    // 新增 / 修改
    addOrUpdateHandle (id) {
      this.addOrUpdateVisible = true
      this.$nextTick(() => {
        this.$refs.addOrUpdate.init(id)
      })
    },
    // 删除
    deleteHandle (id) {
      var ids = id ? [id] : this.dataListSelections.map(item => {
        return item.brandId
      })
      this.$confirm(`确定对[id=${ids.join(',')}]进行[${id ? '删除' : '批量删除'}]操作?`, '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }).then(() => {
        this.$http({
          url: this.$http.adornUrl('product/brand/delete'),
          method: 'post',
          data: this.$http.adornData(ids, false)
        }).then(({data}) => {
          if (data && data.code === 0) {
            this.$message({
              message: '操作成功',
              type: 'success',
              duration: 1500,
              onClose: () => {
                this.getDataList()
              }
            })
          } else {
            this.$message.error(data.msg)
          }
        })
      })
    }
  }
}
</script>
```

- brand-add-or-update.vue

```vue
<template>
  <el-dialog
      :title="!dataForm.id ? '新增' : '修改'"
      :close-on-click-modal="false"
      :visible.sync="visible">
    <el-form :model="dataForm" :rules="dataRule" ref="dataForm" @keyup.enter.native="dataFormSubmit()"
             label-width="140px">
      <el-form-item label="品牌名" prop="name">
        <el-input v-model="dataForm.name" placeholder="品牌名"></el-input>
      </el-form-item>
      <el-form-item label="品牌logo地址" prop="logo">
        <single-upload v-model="dataForm.logo"></single-upload>
      </el-form-item>
      <el-form-item label="介绍" prop="descript">
        <el-input v-model="dataForm.descript" placeholder="介绍"></el-input>
      </el-form-item>
      <el-form-item label="显示状态" prop="showStatus">
        <el-switch
          :active-value="1"
          :inactive-value="0"
          v-model="dataForm.showStatus"
          active-color="#13ce66"
          inactive-color="#ff4949">
        </el-switch>
      </el-form-item>
      <el-form-item label="检索首字母" prop="firstLetter">
        <el-input v-model="dataForm.firstLetter" placeholder="检索首字母"></el-input>
      </el-form-item>
      <el-form-item label="排序" prop="sort">
        <el-input v-model.number="dataForm.sort" placeholder="排序"></el-input>
      </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="visible = false">取消</el-button>
      <el-button type="primary" @click="dataFormSubmit()">确定</el-button>
    </span>
  </el-dialog>
</template>

<script>
import SingleUpload from '@/components/upload/singleUpload'
export default {
  components: {SingleUpload},
  data () {
    return {
      visible: false,
      dataForm: {
        brandId: 0,
        name: '',
        logo: '',
        descript: '',
        showStatus: '',
        firstLetter: '',
        sort: 0
      },
      dataRule: {
        name: [
          {required: true, message: '品牌名不能为空', trigger: 'blur'}
        ],
        logo: [
          {required: true, message: '品牌logo地址不能为空', trigger: 'blur'}
        ],
        descript: [
          {required: true, message: '介绍不能为空', trigger: 'blur'}
        ],
        showStatus: [
          {required: true, message: '显示状态[0-不显示；1-显示]不能为空', trigger: 'blur'}
        ],
        firstLetter: [
          {
            validator: (rule, value, callback) => {
              if (value === '') {
                callback(new Error('首字母必须填写'))
              } else if (!/^[a-zA-Z]$/.test(value)) {
                callback(new Error('首字母必须在[a-z或者A-Z]之间'))
              } else {
                callback()
              }
            }, trigger: 'blur'
          }
        ],
        sort: [
          {
            validator: (rule, value, callback) => {
              if (value === '') {
                callback(new Error('排序字段必须填写'))
              } else if (!Number.isInteger(value) || value < 0) {
                callback(new Error('排序字段必须是大于0的整数'))
              } else {
                callback()
              }
            }, trigger: 'blur'
          }
        ]

      }
    }
  },
  methods: {
    init (id) {
      this.dataForm.brandId = id || 0
      this.visible = true
      this.$nextTick(() => {
        this.$refs['dataForm'].resetFields()
        if (this.dataForm.brandId) {
          this.$http({
            url: this.$http.adornUrl(`product/brand/info/${this.dataForm.brandId}`),
            method: 'get',
            params: this.$http.adornParams()
          }).then(({data}) => {
            if (data && data.code === 0) {
              this.dataForm.name = data.brand.name
              this.dataForm.logo = data.brand.logo
              this.dataForm.descript = data.brand.descript
              this.dataForm.showStatus = data.brand.showStatus
              this.dataForm.firstLetter = data.brand.firstLetter
              this.dataForm.sort = data.brand.sort
            }
          })
        }
      })
    },
    // 表单提交
    dataFormSubmit () {
      this.$refs['dataForm'].validate((valid) => {
        if (valid) {
          this.$http({
            url: this.$http.adornUrl(`product/brand/${!this.dataForm.brandId ? 'save' : 'update'}`),
            method: 'post',
            data: this.$http.adornData({
              'brandId': this.dataForm.brandId || undefined,
              'name': this.dataForm.name,
              'logo': this.dataForm.logo,
              'descript': this.dataForm.descript,
              'showStatus': this.dataForm.showStatus,
              'firstLetter': this.dataForm.firstLetter,
              'sort': this.dataForm.sort
            })
          }).then(({data}) => {
            if (data && data.code === 0) {
              this.$message({
                message: '操作成功',
                type: 'success',
                duration: 1500,
                onClose: () => {
                  this.visible = false
                  this.$emit('refreshDataList')
                }
              })
            } else {
              this.$message.error(data.msg)
            }
          })
        }
      })
    }
  }
}
</script>
```

在`src/新增一个upload目录存放下面的三个插件`

- multiUpload.vue

```vue
<template>
  <div>
    <el-upload
      action="http://gulimall-waer.oss-cn-hangzhou.aliyuncs.com"
      :data="dataObj"
      list-type="picture-card"
      :file-list="fileList"
      :before-upload="beforeUpload"
      :on-remove="handleRemove"
      :on-success="handleUploadSuccess"
      :on-preview="handlePreview"
      :limit="maxCount"
      :on-exceed="handleExceed"
    >
      <i class="el-icon-plus"></i>
    </el-upload>
    <el-dialog :visible.sync="dialogVisible">
      <img width="100%" :src="dialogImageUrl" alt/>
    </el-dialog>
  </div>
</template>
<script>
import {policy} from './policy'
import {getUUID} from '@/utils'

export default {
  name: 'multiUpload',
  props: {
    //图片属性数组
    value: Array,
    //最大上传图片数量
    maxCount: {
      type: Number,
      default: 30
    }
  },
  data () {
    return {
      dataObj: {
        policy: '',
        signature: '',
        key: '',
        ossaccessKeyId: '',
        dir: '',
        host: '',
        uuid: ''
      },
      dialogVisible: false,
      dialogImageUrl: null
    }
  },
  computed: {
    fileList () {
      let fileList = []
      for (let i = 0; i < this.value.length; i++) {
        fileList.push({url: this.value[i]})
      }

      return fileList
    }
  },
  mounted () {
  },
  methods: {
    emitInput (fileList) {
      let value = []
      for (let i = 0; i < fileList.length; i++) {
        value.push(fileList[i].url)
      }
      this.$emit('input', value)
    },
    handleRemove (file, fileList) {
      this.emitInput(fileList)
    },
    handlePreview (file) {
      this.dialogVisible = true
      this.dialogImageUrl = file.url
    },
    beforeUpload (file) {
      let _self = this
      return new Promise((resolve, reject) => {
        policy()
          .then(response => {
            console.log('这是什么${filename}')
            _self.dataObj.policy = response.data.policy
            _self.dataObj.signature = response.data.signature
            _self.dataObj.ossaccessKeyId = response.data.accessid
            _self.dataObj.key = response.data.dir + '/' + getUUID() + '_${filename}'
            _self.dataObj.dir = response.data.dir
            _self.dataObj.host = response.data.host
            resolve(true)
          })
          .catch(err => {
            console.log('出错了...', err)
            reject(false)
          })
      })
    },
    handleUploadSuccess (res, file) {
      this.fileList.push({
        name: file.name,
        // url: this.dataObj.host + "/" + this.dataObj.dir + "/" + file.name； 替换${filename}为真正的文件名
        url: this.dataObj.host + '/' + this.dataObj.key.replace('${filename}', file.name)
      })
      this.emitInput(this.fileList)
    },
    handleExceed (files, fileList) {
      this.$message({
        message: '最多只能上传' + this.maxCount + '张图片',
        type: 'warning',
        duration: 1000
      })
    }
  }
}
</script>
<style>
</style>
```

- singleUpload

```vue
<template> 
  <div>
    <el-upload
      action="http://gulimall-waer.oss-cn-hangzhou.aliyuncs.com"
      :data="dataObj"
      list-type="picture"
      :multiple="false" :show-file-list="showFileList"
      :file-list="fileList"
      :before-upload="beforeUpload"
      :on-remove="handleRemove"
      :on-success="handleUploadSuccess"
      :on-preview="handlePreview">
      <el-button size="small" type="primary">点击上传</el-button>
      <div slot="tip" class="el-upload__tip">只能上传jpg/png文件，且不超过10MB</div>
    </el-upload>
    <el-dialog :visible.sync="dialogVisible">
      <img width="100%" :src="fileList[0].url" alt="">
    </el-dialog>
  </div>
</template>
<script>
import {policy} from './policy'
import {getUUID} from '@/utils'

export default {
  name: 'singleUpload',
  props: {
    value: String
  },
  computed: {
    imageUrl () {
      return this.value
    },
    imageName () {
      if (this.value != null && this.value !== '') {
        return this.value.substr(this.value.lastIndexOf('/') + 1)
      } else {
        return null
      }
    },
    fileList () {
      return [{
        name: this.imageName,
        url: this.imageUrl
      }]
    },
    showFileList: {
      get: function () {
        return this.value !== null && this.value !== '' && this.value !== undefined
      },
      set: function (newValue) {
      }
    }
  },
  data () {
    return {
      dataObj: {
        policy: '',
        signature: '',
        key: '',
        ossaccessKeyId: '',
        dir: '',
        host: '',
        // callback:'',
      },
      dialogVisible: false
    }
  },
  methods: {
    emitInput (val) {
      this.$emit('input', val)
    },
    handleRemove (file, fileList) {
      this.emitInput('')
    },
    handlePreview (file) {
      this.dialogVisible = true
    },
    beforeUpload (file) {
      let _self = this
      return new Promise((resolve, reject) => {
        policy().then(response => {
          _self.dataObj.policy = response.data.policy
          _self.dataObj.signature = response.data.signature
          _self.dataObj.ossaccessKeyId = response.data.accessid
          _self.dataObj.key = response.data.dir + getUUID() + '_${filename}'
          _self.dataObj.dir = response.data.dir
          _self.dataObj.host = response.data.host
          resolve(true)
        }).catch(err => {
          reject(false)
        })
      })
    },
    handleUploadSuccess (res, file) {
      console.log('上传成功...')
      this.showFileList = true
      this.fileList.pop()
      this.fileList.push({
        name: file.name,
        url: this.dataObj.host + '/' + this.dataObj.key.replace('${filename}', file.name)
      })
      this.emitInput(this.fileList[0].url)
    }
  }
}
</script>
<style>

</style>


```

- policy

```javascript
import http from '@/utils/httpRequest.js'

export function policy () {
  return new Promise((resolve, reject) => {
    http({
      url: http.adornUrl('thirdparty/oss/policy'),
      method: 'get',
      params: http.adornParams({})
    }).then(({data}) => {
      resolve(data)
    })
  })
}
```

****

## 品牌信息增改-表单后端校验/异常处理

### 需求分析

前端防君子，后端防小人。

### 代码实现

后端校验使用JSR303进行表单校验。

```
 1）、给Bean添加校验注解:javax.validation.constraints，并定义自己的message提示
*   2)、开启校验功能@Valid
*      效果：校验错误以后会有默认的响应；
*   3）、给校验的bean后紧跟一个BindingResult，就可以获取到校验的结果
*   4）、分组校验（多场景的复杂校验）
*         1)、  @NotBlank(message = "品牌名必须提交",groups = {AddGroup.class,UpdateGroup.class})
*          给校验注解标注什么情况需要进行校验
*         2）、@Validated({AddGroup.class})
*         3)、默认没有指定分组的校验注解@NotBlank，在分组校验情况@Validated({AddGroup.class})下不生效，只会在@Validated生效；
*
*   5）、自定义校验
*      1）、编写一个自定义的校验注解
*      2）、编写一个自定义的校验器 ConstraintValidator
*      3）、关联自定义的校验器和自定义的校验注解
        *      @Documented
        * @Constraint(validatedBy = { ListValueConstraintValidator.class【可以指定多个不同的校验器，适配不同类型的校验】 })
        * @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
        * @Retention(RUNTIME)
        * public @interface ListValue {
     4、统一的异常处理
 * @ControllerAdvice
 *  1）、编写异常处理类，使用@ControllerAdvice。
 *  2）、使用@ExceptionHandler标注方法可以处理的异常。   
```

在common包下新建一个valid目录,存放分组校验和自定义校验的接口。

![image-20220811203438210](https://images.waer.ltd/img/image-20220811203438210.png)

其中，对于:

> AddGroup
>
> UploadGroup
>
> UploadStatusGroup

只需要创建一个空的接口即可，无需做任何实现。对于`ListValue`，这是我们自定义的校验注解，用来校验品牌的状态展示字段，规则是只运行1和0，其他内容不允通过。实现如下：

```java
package com.atguigu.common.valid;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

@SuppressWarnings("all")

/**
 * @author: 八尺妖剑
 * @date: 2022 2022/8/11 17:58
 * @email: ilikexff.gmail.com
 * @blog: https://www.waer.ltd
 */

/**
 * 自定义校验注解
 * 校验必须包含指定的值
 */
@Documented
@Constraint(validatedBy = { ListValueConstraintValidator.class })
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface ListValue {
    String message() default "{com.atguigu.common.valid.ListValue.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    int[] vals() default { };
}
```

上面的内容只是按照校验注解的规则创建的自定义注解。其中，我们需要自己实现校验的逻辑，主要实现在`ListValueConstraintValidator`中。

```java
package com.atguigu.common.valid;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.util.HashSet;
import java.util.Set;

@SuppressWarnings("all")
/**
 * @author: 八尺妖剑
 * @date: 2022 2022/8/11 18:39
 * @email: ilikexff.gmail.com
 * @blog: https://www.waer.ltd
 */
public class ListValueConstraintValidator implements ConstraintValidator<ListValue,Integer> {
    private Set<Integer> set = new HashSet<>();
    @Override
    public void initialize(ListValue constraintAnnotation) {
        int[] vals = constraintAnnotation.vals();
        for(int val : vals) {
            set.add(val);
        }
    }

    @Override
    public boolean isValid(Integer integer, ConstraintValidatorContext constraintValidatorContext) {
        return set.contains(integer);
    }
}
```

在initialize方法中，我们需要通过constraintAnnotation取到前端传过来的表单值，存入数组，遍历整个数组将值全部添加到set集合中，在第二个方法isValid中，只需要判断集合是否包含了指定的值和方法中的参数`integer`是否相同，相同说明符合校验规则，否则false掉。

给实体`Brand`加上校验注解

```java
package com.atguigu.gulimall.product.entity;

import com.atguigu.common.valid.AddGroup;
import com.atguigu.common.valid.ListValue;
import com.atguigu.common.valid.UpdateGroup;
import com.atguigu.common.valid.UpdateStatusGroup;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serializable;

import lombok.Data;
import org.hibernate.validator.constraints.URL;

import javax.validation.constraints.*;

/**
 * 品牌
 * 
 * @author 八尺妖剑
 * @email ilikexff@gmail.com
 * @date 2019-10-01 21:08:49
 */
@Data
@TableName("pms_brand")
public class BrandEntity implements Serializable {
	private static final long serialVersionUID = 1L;

	/**
	 * 品牌id
	 */
	@NotNull(message = "修改必须指定品牌id",groups = {UpdateGroup.class})
	@Null(message = "新增不能指定id",groups = {AddGroup.class})
	@TableId
	private Long brandId;
	/**
	 * 品牌名
	 */
	@NotBlank(message = "品牌名必须提交",groups = {AddGroup.class,UpdateGroup.class})
	private String name;
	/**
	 * 品牌logo地址
	 */
	@NotBlank(groups = {AddGroup.class})
	@URL(message = "logo必须是一个合法的url地址",groups={AddGroup.class,UpdateGroup.class})
	private String logo;
	/**
	 * 介绍
	 */
	private String descript;
	/**
	 * 显示状态[0-不显示；1-显示]
	 */
//	@Pattern()
	@NotNull(groups = {AddGroup.class, UpdateStatusGroup.class})
  	@ListValue(vals={0,1},groups = {AddGroup.class, UpdateStatusGroup.class})
	private Integer showStatus;
	/**
	 * 检索首字母
	 */
	@NotEmpty(groups={AddGroup.class})
	@Pattern(regexp="^[a-zA-Z]$",message = "检索首字母必须是一个字母",groups={AddGroup.class,UpdateGroup.class})
	private String firstLetter;
	/**
	 * 排序
	 */
	@NotNull(groups={AddGroup.class})
	@Min(value = 0,message = "排序必须大于等于0",groups={AddGroup.class,UpdateGroup.class})
	private Integer sort;
}
```

对应的，我们需要在使用校验的方法上(新增和修改的方法)的参数中添加Validated()并传入对应的校验组的.class即可，比如：

```java
@RequestMapping("/update/status")
    //@RequiresPermissions("product:brand:update")
    public R updateStatus(@Validated(UpdateStatusGroup.class) @RequestBody BrandEntity brand){
        brandService.updateById(brand);
        return R.ok();
    }
```

**统一异常处理**

由于项目需要处理的异常类型很多，我们把异常的类型和状态码按照一定的规则创建一个枚举类。在`common`服务的`/excrption`包下：

```java
package com.atguigu.common.exception;

/***
 * 错误码和错误信息定义类
 * 1. 错误码定义规则为5为数字
 * 2. 前两位表示业务场景，最后三位表示错误码。例如：100001。10:通用 001:系统未知异常
 * 3. 维护错误码后需要维护错误描述，将他们定义为枚举形式
 * 错误码列表：
 *  10: 通用
 *      001：参数格式校验
 *  11: 商品
 *  12: 订单
 *  13: 购物车
 *  14: 物流
 */

/**
 * @author: 八尺妖剑
 * @date: 2022 2022/8/11 17:09
 * @email: ilikexff.gmail.com
 * @blog: https://www.waer.ltd
 */
@SuppressWarnings("all")
public enum BizCodeEnume {
    /**
     * 系统未知异常
     */
    UNKNOW_EXCEPTION(10000,"系统未知异常"),
    /**
     * 参数格式异常
     */
    VAILD_EXCEPTION(10001,"参数格式校验失败");

    /**
     *异常状态码
     */
    private int code;
    /**
     * 异常信息
     */
    private String msg;

    /**
     * 封装异常返回信息
     * @param code 状态码
     * @param msg 异常信息
     */
    BizCodeEnume(int code,String msg){
        this.code = code;
        this.msg = msg;
    }

    /**
     * 异常信息空参构造
     * @return 异常状态码
     */
    public int getCode() {
        return code;
    }

    /**
     * 异常信息
     * @return 异常信息
     */
    public String getMsg() {
        return msg;
    }
}
```

在product服务下的新建一个excrption包，并实现异常的统一处理。

```java
package com.atguigu.gulimall.product.exception;

import com.atguigu.common.exception.BizCodeEnume;
import com.atguigu.common.utils.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("all")
/**
 * @author: 八尺妖剑
 * @date: 2022 2022/8/11 17:09
 * @email: ilikexff.gmail.com
 * @blog: https://www.waer.ltd
 */
@Slf4j
@RestControllerAdvice(basePackages = "com.atguigu.gulimall.product.controller")
public class GulimallExceptionControllerAdvice {


    /**
     * 已知异常类型统一处理
     * @param e 异常
     * @return R
     */
    @ExceptionHandler(value= MethodArgumentNotValidException.class)
    public R handleVaildException(MethodArgumentNotValidException e){
        log.error("数据校验出现问题{}，异常类型：{}",e.getMessage(),e.getClass());
        BindingResult bindingResult = e.getBindingResult();
        Map<String,String> errorMap = new HashMap<>(16);
        bindingResult.getFieldErrors().forEach((fieldError)->{
            errorMap.put(fieldError.getField(),fieldError.getDefaultMessage());
        });
        return R.error(BizCodeEnume.VAILD_EXCEPTION.getCode(),BizCodeEnume.VAILD_EXCEPTION.getMsg()).put("data",errorMap);
    }

    /**
     * 全局未定义异常处理
     * @param throwable 异常
     * @return R
     */
    @ExceptionHandler(value = Throwable.class)
    public R handleException(Throwable throwable){

        log.error("错误：",throwable);
        return R.error(BizCodeEnume.UNKNOW_EXCEPTION.getCode(),BizCodeEnume.UNKNOW_EXCEPTION.getMsg());
    }

}
```

****

## 重要说明

> 笔记暂停更新… 
